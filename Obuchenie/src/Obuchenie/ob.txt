Методы{
void - нечего не возвращает не надо прописывать return
return - возвращает, и сразу выходит из метода
Методы с доп партаметром, должно быть указанно какой парамерт он будет устастанавливать{
String name;
void setName(String username){
    name = usename;
}
person1 = setName("Рома")
}
}

Инкапсуляция{
private  - можно использовать только в том классе в котором оно обозначенно
set - обозначает
get - возвращает
.isEmpty - проверяет пустая или нет сторока String
}

this{
public class Main {
    public static void main(String[] args) {
        Human human1 = new Human();
        human1.setAge(18);
        human1.setName("Tom");
        human1.getInfo();
    }

}
class Human{

    private String name;
    private int age;
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void getInfo(){
        System.out.println(name + "," + age);
    }
}
}
static{
она пренадлежит классу
находится перед типом переменной
можно обратится сразу к имени класса
}
final{
константа, не изменяема
не можем созать set
их надо делать static
}
StringBuilder{
StringBuilder sb = new StringBuilder("Hello");
        sb.append(" Good").append(" my").append("gggg").append("123");
        System.out.println(sb.toString());
}
Наследование{
extends - наследует что то из другого класса и расширяет его
}
Интерфейсы{
В них не может быть реализации метода а только сигнатура
implements - другие классы обязаны реализовать в себе методы из интерфейса
Можно создавать обекты вот так если они реализуют методы из интерфейса
Info info1 = new Animal(1);
Info info2 = new Person("Tom");    и можно вызывать только те методы которые реализованны в классах из интерфейса
}
пакеты{
используются для логического разграничевания классов
}
Приметивы{
float f = 123.1f;
long l = 12390L;
Конвертация из long в int
int x = (int) l;
}