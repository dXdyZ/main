&& - оператор и
|| - оператор или
? : - оператор сокращенный
!= - оператор не равно
+= - сложение с присвоением
класс это сбор методов
length - длина чего либо строки или массива
метод static - можно вызывать без создания объекта
this - обращается к переменным и обьекам всего классва вызывать когда есть переменные одинаковы и нужна так которая относится к объекту
public static final int LEGS_COUNT - так прописываются константы
get - возвращает переменную
set - устанавливает переменную
Coloring color = Coloring.BLACK;-вот так вот ссылаться на параметры из фала ENUM.
    public void setColor(Coloring color){
        this.color = color;
    }						Пример сетера и гетера

    public Coloring getColor() {
        return color;
    }

 при создании обьека из пакетов надо использовать .getInstance();

преобразования проходит с помощью - lonh h = (int) 6

чисто парсится с момошью -  String  nim = "2344.3434";
float aFloat = Float.parseFloat(nim) - переводит из строки в число
вот так проходит приобразования чисел в строку
Integer a = 234455;
System.out.println(a.toString());
chartAt - вызвать символ по его номеры
конкотинация строк делается с помощью +
StringBuilder - позволяет добовлять к нему строки
  	String name1 = "Timur";
        String name2 = "Regina";
        // создаем его
        StringBuilder bild = new StringBuilder();
	// вызывем секундомер
        long start = System.currentTimeMillis();
        // создаем цикл
        for (int i = 0; i < 1000000; i++){
            bild.append(name2);
        }
        long end = System.currentTimeMillis();
        // закрываем секундомер

	// выводим время выполения с конкотинацией строк в скобках
        System.out.println("Время выполнения: " + (end - start) + "ms");
        // узнаем длинну получившейся строки
        System.out.println(bild.length());
приме кода с выводом времени его выполнения

сравнение строк  можно делать с помощью строка.equals(строка)
сравнение строк с игнорирование закглавных и прописных букв System.out.println(name1.compareToIgnoreCase(name2));
переменная.split - разбивает на предложения надо прописывать "\\.\\s+"
пример кода с массивом:
	String text = "Дмитрий Петрович ждет вас.   Выходите через 5 минут";
      String[] centr = text.split("\\.\\s+");
      for(int i = 0; i < centr.length; i++){
          System.out.println(centr[i]);

 HashMap есть методы
 .put - пишется ключ и значение
 .get - на вход получает ключ и выдает значение
 .remove - можно удалить определенный ключ

 for(String key : map.keySet()){
            System.out.println(key + "->" + map.get(key));
        } - с помощью этого цикла можно переберать ключи

TreeMap - в алфовитном порядке

Прописывая extends в классе - мы можем наследовать из другого класса

Comparable - сравнимый
он обаязывает реализовать ComparabaleTo
Comparator - надо обьявлять для каждого класса новый он сравнивает так же как и Comparable

:: - указатели на метод
forEach - сокращает вывод

Stream API. Его задача - упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными. Вся основная функциональность данного API сосредоточена в пакете java.util.stream. Ключевым понятием в Stream API является поток данных. Вообще сам термин "поток" довольно перегружен в программировании в целом и в Java в частности.
stream.filter(employee -> employee.getSalary() >= 100000).forEach(System.out::println); - пример кода с выводом только сотрудников с зарплатой больше или равно 100000
Stream.iterate(1, n -> n + 1).forEach(System.out::println); - бесконечный стрим


Методы{
статические методы можно вызывать без создания объекта
void - нечего не возвращает не надо прописывать return
return - возвращает, и сразу выходит из метода
Методы с доп партаметром, должно быть указанно какой парамерт он будет устастанавливать{
String name;
void setName(String username){
    name = usename;
}
person1 = setName("Рома")
}
}

Инкапсуляция{
private  - можно использовать только в том классе в котором оно обозначенно
set - обозначает
get - возвращает
.isEmpty - проверяет пустая или нет сторока String
}

this{
public class Main {
    public static void main(String[] args) {
        Human human1 = new Human();
        human1.setAge(18);
        human1.setName("Tom");
        human1.getInfo();
    }

}
class Human{

    private String name;
    private int age;
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void getInfo(){
        System.out.println(name + "," + age);
    }
}
}


static{
она пренадлежит классу
находится перед типом переменной
можно обратится сразу к имени класса
}
final{
константа, не изменяема
не можем созать set
их надо делать static
}
StringBuilder{
StringBuilder sb = new StringBuilder("Hello");
        sb.append(" Good").append(" my").append("gggg").append("123");
        System.out.println(sb.toString());
}


Наследование{
extends - наследует что то из другого класса и расширяет его
}
Интерфейсы{
В них не может быть реализации метода а только сигнатура
implements - другие классы обязаны реализовать в себе методы из интерфейса
Можно создавать обекты вот так если они реализуют методы из интерфейса
Info info1 = new Animal(1);
Info info2 = new Person("Tom");    и можно вызывать только те методы которые реализованны в классах из интерфейса
}
пакеты{
используются для логического разграничевания классов
}


Приметивы{
float f = 123.1f;
long l = 12390L;
Конвертация из long в int
int x = (int) l;
}
Восходящее и нисходящее преобразование{
Восходящее преобразование
Animal animak = new Dog();
нисходящее преобразование
Dog dog2 = (Dog) animal;
}
Wildcards (Generics){
public String toString(){
        return String.valueOf(id); целое число id конвертируется в строку
    }
public static void test(List<? extends Animal> list) - знак вопроса говорит о том что можно пераедать лист любых обьектов -
extends говорит что мы можем поставить туда матоды либо Animal либо те которые наследуют класс энимал
super - говорит о том что мы хотим видет все классы выше Animal
List<Animal> listOfAnimal = new ArrayList<>();
        listOfAnimal.add(new Animal(1));
        listOfAnimal.add(new Animal(2));

        List<Dog> fDogs = new ArrayList<>();
        fDogs.add(new Dog());
        fDogs.add(new Dog());


        test(listOfAnimal);
        test(fDogs);
    }
    public static void test(List<? extends Animal> list){
        for (Animal animal : list){
            animal.eat();
        }
    }
}
class Animal{
    private int id;
    public Animal(){}

    public Animal(int id){
        this.id = id;
    }
    public void eat(){
        System.out.println("i am eatig");
    }
    public String toString(){
        return String.valueOf(id);
    }
}

class Dog extends Animal{}
}
анонимные классы{
         Animal animal = new Animal();
         animal.eat();
         // переопределяем метод eat из класса Animal
         Animal animal1 = new Animal(){ // создается не обьект класса Animal а его наследник
             public void eat(){
                 System.out.println("Other animal");
             }
         };
         animal1.eat();
     }
 }
 class Animal{
     public void eat(){
         System.out.println("Animal is eating...");
     }
 }

Если нужно содать класс на одно использование то реализуем с помощью интерейса
создать объект этого класса можно только один раз
AnimalToEat animalToEat = new AnimalToEat() {
            @Override
            public void eat() {
                System.out.println("is eating");
            }
        };
     }
 }
 interface AnimalToEat {
     public void eat();
 }
}


Интерфейс - говорим что должно быть реализованно но не говорим как оно должно быть реализованно
Работа с файлами через сканер{
 String path = "test.txt";
File file = new File(path);
Scanner scanner = new Scanner(file);

String line = scanner.nextLine();
String[] numbers = line.split(" ");
for (String number : numbers){
    Integer.parseInt(number); // парсим строку в число
}
System.out.println(Arrays.toString(numbers));

scanner.close();
}


Исключения{
FileNotFoundException - исключение вызывается если файла не существует
throws - можно объявить сразу при создании метода и он будет говорить о том что при выполнении
метода может возникнуть исключение
что бы где-то в коде выбросить исключение нужно использовать throw new исключение
 Scanner scanner = new Scanner(System.in);
        while (true){
           int x = Integer.parseInt(scanner.nextLine());
           if (x != 0){
               throw new ScannerExeption("not zero");
           }
        }
    }
}
class ScannerExeption extends Exception{ - создаем своё исключение и наследуемся от класса Exception
    public ScannerExeption(String desc){ - создаем метод для вводе своих сообщений
        super(desc);
    }
}
Checked - проверяемый исключения которые возникают во время компиляции, исключительные случаи в работе программы
UnChecked - во время работы программы, ошибка в работе программы: String name = null;
                                                                   name.length()
из одного метода можно выбрать множество исключений, так же может быть множество catch
}


Абстрактные классы{
abstract - запрещает создавать объекты класса, но можем создавать наследников этого класс
только в абстрактных классах можно создавать абстрактные методы
}
String string2 = "Hello123".substring(0, 5) - отсечет первые 5 букв последний элемент не включительно
Animal animal1 = new Animal(1);
Animal animal2 = animal1; - приравниваем второй обьект к первому у него тоже будет 1

Метод equals() и String Pool{
equals - сравнивает обьекты как ссылки  Animal animal1 = new Animal(1);
                                        Animal animal2 = new Animal(2);
                                        System.out.println(animal1.equals(animal2));
private int id;
public boolean equals(Object obj){ // переопределяем метод equals
        Animal otherAnimal = (Animal) obj; // даункастим его
        return this.id == otherAnimal.id; // сравниваем по id
    }
}


Вложенные классы{
Не статический вложенный класс - обычно приватные, они относятся к объекту и имеют доступ к его полям использовать тогда когда класс сложный и можно разделить
на несколько под объектов, чаще всего приватные
Статический вложенный класс - он не имеет достпу к полям класс, но может получать доступ к статическим полям обычно паблик
вот так вызываетс Electrocar.Batarry batarry = new Electrocar.Batarry();
Вложенные классы которые находятся в методе - имеет доступ к полям класса, может получать доступ к переменным этого метода если только они константы
class Electrocar{
    public int id;
    //Не статический вложенный класс
    private class Motor{
        public void startMotor(){
            System.out.println("Motor is starting...");
        }
    }

    // Статический вложенный класс
    public static class Batarry{
        public void charge(){
            System.out.println("chargeng");
        }
    }

    public Electrocar(int id) {
        this.id = id;
    }
    public void start(){
        Motor motor = new Motor();
        motor.startMotor();

        final int x = 1;
    // Вложенные классы которые находятся в методе
        class SameClass {
            public void someMether(){
                System.out.println(x);
                System.out.println(id);
            }
        }
        System.out.println("Electrocar " + id + "is starting...");
    }

}
}


Запись в файл{
Запись строковых данных
PrintWriter - предназначен только для записи строк
File file = new File("tets");
PrintWriter ow = new PrintWriter(file);
ow.println("Test or 1"); - записываем первую строку
ow.println("Test or 2"); - записываем вторую строку
ow.close();
}

Запись обьектов{
Первый способ
Сериализация объектов
import java.io.*;

public class Main {
    // Запись в файл
    public static void main(String[] args){
        Person person1 = new Person(1, "Tom");   // создаем объект для записи
        Person person2 = new Person(2, "Maks");  // создаем объект для записи

        try {
            FileOutputStream fos = new FileOutputStream("/home/dxdyz/GIT/main/Obuchenie/pesronBin.bin"); - переводим данные в байты
            ObjectOutputStream oos = new ObjectOutputStream(fos); - работает с этим дынными

            oos.writeObject(person1);  - записываем объект1 в файл
            oos.writeObject(person2);  - записываем объект2 в файл

            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class Person implements Serializable{
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String toString(){
        return id + "," + name;
    }
}

// Чтение из файла
class ReadObject{
    public static void main(String[] args) {
        try {
            FileInputStream fip = new FileInputStream("/home/dxdyz/GIT/main/Obuchenie/pesronBin.bin");
            ObjectInputStream oos = new ObjectInputStream(fip);

            Person person1 = (Person) oos.readObject(); - создаем объект и даункасим его, так же передаем ему данные из файл
            Person person2 = (Person) oos.readObject(); - создаем объект и даункасим его, так же передаем ему данные из файл

            System.out.println(person1);
            System.out.println(person2);

            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
}

Сериализация массивов{
public class Main {
    // Запись в файл
    public static void main(String[] args){
        Person[] people = {new Person (1, "Tom"),
                new Person(2, "Maks")};

        try {
            FileOutputStream fos = new FileOutputStream("/home/dxdyz/GIT/main/Obuchenie/pesronBin.bin");
            ObjectOutputStream oos = new ObjectOutputStream(fos);

            oos.writeInt(people.length); // длинна массива
            for (Person person: people){
                oos.writeObject(person); // записываем в масив
            }

            fos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class Person implements Serializable{
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String toString(){
        return id + "," + name;
    }
}

// Чтение из файла
class ReadObject{
    public static void main(String[] args) {
        try {
            FileInputStream fip = new FileInputStream("/home/dxdyz/GIT/main/Obuchenie/pesronBin.bin");
            ObjectInputStream oos = new ObjectInputStream(fip);

            int perconCount = oos.readInt(); // считываем число

            Person[] people = new Person[perconCount];
            for (int i = 0; i < perconCount; i++){
                people[i] = (Person) oos.readObject(); // записываем считанные объекты
            }

            System.out.println(Arrays.toString(people)); // выводим масив

            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
Второй способ
Записать челеком масив из обьектов
достаточно записать масив
public class Main {
    // Запись в файл
    public static void main(String[] args){
        Person[] people = {new Person (1, "Tom"),
                new Person(2, "Maks")};

        try {
            FileOutputStream fos = new FileOutputStream("/home/dxdyz/GIT/main/Obuchenie/pesronBin.bin");
            ObjectOutputStream oos = new ObjectOutputStream(fos);

            oos.writeObject(people); // Записываем массив

            fos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class Person implements Serializable{
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String toString(){
        return id + "," + name;
    }
}

// Чтение из файла
class ReadObject{
    public static void main(String[] args) {
        try {
            FileInputStream fip = new FileInputStream("/home/dxdyz/GIT/main/Obuchenie/pesronBin.bin");
            ObjectInputStream oos = new ObjectInputStream(fip);


            Person[] people = (Person[]) oos.readObject(); // возвратит тот объект, который был записан в файл

            System.out.println(Arrays.toString(people)); // выводим масив

            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
Сериализация Transient, serialVersionUID{
Transient - используеся тогда когда не хотим сериализововать какое то поле: private transient String name; // это поле не будет сериализоваться
public class Main {
    // Запись в файл
    public static void main(String[] args){
        Person person1 = new Person(1, "Tom");

        try (ObjectInputStream oos = new ObjectInputStream(
                new FileInputStream("/home/dxdyz/GIT/main/Obuchenie/pesronBin.bin"))){
            oos.writeObject(person1); // Записываем массив
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class ReadObject{
    public static void main(String[] args) {
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("/home/dxdyz/GIT/main/Obuchenie/pesronBin.bin"))) { // реализовываем автоматическое закрытие потока

            Person[] people = (Person[]) ois.readObject(); // возвратит тот объект, который был записан в файл

            System.out.println(Arrays.toString(people)); // выводим масив

        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
}
}

enuma - перечесление{
 Animal animal = Animal.CAT;
        Seson sesons = Seson.AUTUMN;

        switch (animal){
            case CAT:
                System.out.println("its cat");
                break;
        }
    }
}
enum Animal{
    DOG, CAT, FROG
}
enum Seson{
    WINTR, AUTUMN
}
instanceof - проверяет евляется объект объектом этого класа: seson instanceof Seson
Более продвинутый сценарий использования
Season season = Season.AUTUMN;
System.out.println(season.name()); // возвращается имя enumа в виде строки
ss Main {
    public static void main(String[] args) {
        Season season = Season.AUTUMN;
        Animal animal = Animal.CAT;
        System.out.println(season.name()); // возвращается имя enumа в виде строки

        Animal cat = Animal.valueOf("CAT"); // Вернет енам
        System.out.println(cat.getTranslation());
        Season winet = Season.WINTER;
        System.out.println(winet.ordinal()); // вернет индекс енам
    }

}
enum Animal {
    DOG("собака"), CAT("кошка"), FROG("лягушка");

    private String translation;
    Animal() {}
    Animal(String translation){
        this.translation = translation;
    }

    public String getTranslation() {
        return translation;
    }
    public String toString(){
        return translation;
    }
}

enum Season{
    WINTER(-30), AUTUMN(10);

    private int teperatura;

    Season(int teperatura){
        this.teperatura = teperatura;
    }

    public int getTeperatura() {
        return teperatura;
    }
}
}

Рекурсия - вызов метода в теле этого же метода {
условие выхода
class Main{
    public static void main(String[] args) {
        counter(3);
    }

    // counter(3) -> counter(2) -> counter(1)
    private static void counter(int n){
        if(n == 0)
            return;
        System.out.println(n);

        counter(n - 1); // 3, 2, 1
    }
}

}
