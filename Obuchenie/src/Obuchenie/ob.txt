Методы{
void - нечего не возвращает не надо прописывать return
return - возвращает, и сразу выходит из метода
Методы с доп партаметром, должно быть указанно какой парамерт он будет устастанавливать{
String name;
void setName(String username){
    name = usename;
}
person1 = setName("Рома")
}
}

Инкапсуляция{
private  - можно использовать только в том классе в котором оно обозначенно
set - обозначает
get - возвращает
.isEmpty - проверяет пустая или нет сторока String
}

this{
public class Main {
    public static void main(String[] args) {
        Human human1 = new Human();
        human1.setAge(18);
        human1.setName("Tom");
        human1.getInfo();
    }

}
class Human{

    private String name;
    private int age;
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void getInfo(){
        System.out.println(name + "," + age);
    }
}
}
static{
она пренадлежит классу
находится перед типом переменной
можно обратится сразу к имени класса
}
final{
константа, не изменяема
не можем созать set
их надо делать static
}
StringBuilder{
StringBuilder sb = new StringBuilder("Hello");
        sb.append(" Good").append(" my").append("gggg").append("123");
        System.out.println(sb.toString());
}
Наследование{
extends - наследует что то из другого класса и расширяет его
}
Интерфейсы{
В них не может быть реализации метода а только сигнатура
implements - другие классы обязаны реализовать в себе методы из интерфейса
Можно создавать обекты вот так если они реализуют методы из интерфейса
Info info1 = new Animal(1);
Info info2 = new Person("Tom");    и можно вызывать только те методы которые реализованны в классах из интерфейса
}
пакеты{
используются для логического разграничевания классов
}
Приметивы{
float f = 123.1f;
long l = 12390L;
Конвертация из long в int
int x = (int) l;
}
Восходящее и нисходящее преобразование{
Восходящее преобразование
Animal animak = new Dog();
нисходящее преобразование
Dog dog2 = (Dog) animal;
}
Wildcards (Generics){
public String toString(){
        return String.valueOf(id); целое число id конвертируется в строку
    }
public static void test(List<? extends Animal> list) - знак вопроса говорит о том что можно пераедать лист любых обьектов -
extends говорит что мы можем поставить туда матоды либо Animal либо те которые наследуют класс энимал
super - говорит о том что мы хотим видет все классы выше Animal
List<Animal> listOfAnimal = new ArrayList<>();
        listOfAnimal.add(new Animal(1));
        listOfAnimal.add(new Animal(2));

        List<Dog> fDogs = new ArrayList<>();
        fDogs.add(new Dog());
        fDogs.add(new Dog());


        test(listOfAnimal);
        test(fDogs);
    }
    public static void test(List<? extends Animal> list){
        for (Animal animal : list){
            animal.eat();
        }
    }
}
class Animal{
    private int id;
    public Animal(){}

    public Animal(int id){
        this.id = id;
    }
    public void eat(){
        System.out.println("i am eatig");
    }
    public String toString(){
        return String.valueOf(id);
    }
}

class Dog extends Animal{}
}
анонимные классы{
         Animal animal = new Animal();
         animal.eat();
         // переопределяем метод eat из класса Animal
         Animal animal1 = new Animal(){ // создается не обьект класса Animal а его наследник
             public void eat(){
                 System.out.println("Other animal");
             }
         };
         animal1.eat();
     }
 }
 class Animal{
     public void eat(){
         System.out.println("Animal is eating...");
     }
 }

Если нужно содать класс на одно использование то реализуем с помощью интерейса
создать объект этого класса можно только один раз
AnimalToEat animalToEat = new AnimalToEat() {
            @Override
            public void eat() {
                System.out.println("is eating");
            }
        };
     }
 }
 interface AnimalToEat {
     public void eat();
 }
}
Интерфейс - говорим что должно быть реализованно но не говорим как оно дожно быть реализованно
Работа с файлами через сканер{
 String path = "test.txt";
File file = new File(path);
Scanner scanner = new Scanner(file);

String line = scanner.nextLine();
String[] numbers = line.split(" ");
for (String number : numbers){
    Integer.parseInt(number); // парсим строку в чило
}
System.out.println(Arrays.toString(numbers));

scanner.close();
}
Исключения{
FileNotFoundException - исключение вызывается если файла не существует
throws - можно обьявить сразу при создании метода и он будет говорить о том что при выполнении
метода может возникнуть исключение
}